# MongoDB数据同步

实时数据同步以oplog为基础，同步过程包括全量同步和增量同步。

## 全量同步

全量同步是对各个集合的同步，集合作为任务，利用线程池并发处理，每个线程负责一个集合的同步。

当一个集合的文档数特别多，那么该集合花费的时间较长，将拉长整个全量同步的进程，所以对文档数量很大的集合（后面称为“大表”），应该在单表上进行范围划分，形成多个子任务，然后并发处理，提高同步效率。

全量同步策略是，根据文档数量分为大表和小表，大表采用单表内并发，小表采用表级并发。

## 增量同步

oplog同步策略是对非命令类型的oplog并发回放。

oplog并发回放的分组策略是先对namespace进行哈希，再对_id进行二次哈希。

需要注意的是，如果oplog是命令类型，要先解析命令名称，然后确定执行上下文数据库，必要时进行切换。

有些命令的执行上下文必须是`admin`，具体参考[https://docs.mongodb.com/manual/reference/command/nav-administration/](https://docs.mongodb.com/manual/reference/command/nav-administration/)

## 复制集

## 分片集群

分片集群的数据同步，需要预先同步分片配置，并保持实时同步。

> 初始分片配置同步完成或当分片配置发生变更并在目标端应用后，对其他mongos执行命令`flushRouterConfig`，确保各mongos看到config一致

对于分片集群的全量同步，有两种方案：

1. 从mongos读取全部数据
2. 从各个shard读取数据

方案一的优点是从源端读取的数据是真实有效数据，不存在孤立文档，但是慢；
方案二的优点是快，但读出来的数据可能包含孤立文档，导致同步完成后目标端的数据比源端数据要多。

两种方案各有利弊，考虑到生产环境下分片集群往往存储大量数据，如果耗时超过shard复制窗口，将无法进行增量同步，所以我个人更倾向于后者，至于孤立文档和孤立集合的清理，对于分片集群来说，应该作为保持数据健康度的定时任务。

> 如果情况允许，最好关闭源端和目标端的balancer，以提高同步效率

## 需要注意的地方

todo 唯一索引

`MapReduce`操作将建立以“mr.tmp."或”mrs.tmp."开头的临时集合，这类命令需要过滤掉。
